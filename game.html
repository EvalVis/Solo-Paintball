<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>10x10 Grid with Constant-Speed Shooting</title>
<style>
body {
  margin: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  background-color: #eee;
  user-select: none;
}
canvas {
  border: 1px solid black;
}
</style>
</head>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
<script>
const { Engine, Render, World, Bodies, Body, Vector, Events } = Matter;

// Engine
const engine = Engine.create();
engine.gravity.y = 0; // disable gravity

// Grid configuration
const rows = 10;
const cols = 10;
const tileSize = 50;
const width = cols * tileSize;
const height = rows * tileSize;

// Renderer
const render = Render.create({
    element: document.body,
    engine: engine,
    options: {
        width,
        height,
        wireframes: false,
        background: '#fff'
    }
});

// Create grid tiles (visual only, no collisions)
const tiles = [];
for (let row = 0; row < rows; row++) {
    for (let col = 0; col < cols; col++) {
        const x = col * tileSize + tileSize / 2;
        const y = row * tileSize + tileSize / 2;

        const tile = Bodies.rectangle(x, y, tileSize, tileSize, {
            isStatic: true,
            isSensor: true, // <-- makes tile non-collidable
            render: { fillStyle: '#fff', strokeStyle: '#000', lineWidth: 1 }
        });

        tiles.push(tile);
    }
}
World.add(engine.world, tiles);

// Create boundary walls for bouncing
const thickness = 50; // thicker than a tile so balls never escape

const walls = [
    // top
    Bodies.rectangle(width/2, -thickness/2, width, thickness, { isStatic: true }),
    // bottom
    Bodies.rectangle(width/2, height + thickness/2, width, thickness, { isStatic: true }),
    // left
    Bodies.rectangle(-thickness/2, height/2, thickness, height, { isStatic: true }),
    // right
    Bodies.rectangle(width + thickness/2, height/2, thickness, height, { isStatic: true })
];

World.add(engine.world, walls);

// Player
let playerRow = rows - 1;
let playerCol = cols - 1;
const player = Bodies.rectangle(
    playerCol * tileSize + tileSize / 2,
    playerRow * tileSize + tileSize / 2,
    tileSize,
    tileSize,
    {
        isStatic: true,
        render: { fillStyle: 'blue', strokeStyle: '#000', lineWidth: 1 }
    }
);
World.add(engine.world, player);

// Track mouse for direction
let mousePos = { x: width/2, y: height/2 };
render.canvas.addEventListener('mousemove', (e) => {
    const rect = render.canvas.getBoundingClientRect();
    mousePos = {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
    };
});

// Player movement
document.addEventListener('keydown', (event) => {
    let moved = false;
    if (event.key === 'ArrowUp' || event.key.toLowerCase() === 'w') {
        if (playerRow > 0) { playerRow--; moved = true; }
    }
    if (event.key === 'ArrowDown' || event.key.toLowerCase() === 's') {
        if (playerRow < rows - 1) { playerRow++; moved = true; }
    }
    if (event.key === 'ArrowLeft' || event.key.toLowerCase() === 'a') {
        if (playerCol > 0) { playerCol--; moved = true; }
    }
    if (event.key === 'ArrowRight' || event.key.toLowerCase() === 'd') {
        if (playerCol < cols - 1) { playerCol++; moved = true; }
    }
    if (moved) {
        Body.setPosition(player, {
            x: playerCol * tileSize + tileSize / 2,
            y: playerRow * tileSize + tileSize / 2
        });
    }
});

// Array to hold active balls
const balls = [];

// Shoot red ball every 5 seconds
setInterval(() => {
    const playerPos = player.position;
    let dir = Vector.sub(mousePos, playerPos);
    dir = Vector.normalise(dir);
    const speed = 5;

    const spawnDistance = tileSize;
    const spawnPos = {
        x: playerPos.x + dir.x * spawnDistance,
        y: playerPos.y + dir.y * spawnDistance
    };

    const ball = Bodies.circle(spawnPos.x, spawnPos.y, tileSize/6, {
        restitution: 1, // <-- makes it bouncy
        frictionAir: 0,
        render: { fillStyle: 'red' }
    });

    Body.setVelocity(ball, { x: dir.x * speed, y: dir.y * speed }); // initial velocity
    balls.push(ball);
    World.add(engine.world, ball);
}, 5000);

// Listen for collisions
Events.on(engine, 'collisionStart', (event) => {
    const pairs = event.pairs;

    for (const pair of pairs) {
        // Check if player is involved
        if (pair.bodyA === player || pair.bodyB === player) {
            // Check if the other body is a ball
            const ball = pair.bodyA === player ? pair.bodyB : pair.bodyA;
            if (balls.includes(ball)) {
                // Reset the game
                // 1. Remove all balls from world
                balls.forEach(b => World.remove(engine.world, b));
                balls.length = 0;

                // 2. Reset player position
                playerRow = rows - 1;
                playerCol = cols - 1;
                Body.setPosition(player, {
                    x: playerCol * tileSize + tileSize / 2,
                    y: playerRow * tileSize + tileSize / 2
                });
            }
        }
    }
});


// Run engine and renderer
Engine.run(engine);
Render.run(render);
</script>
</body>
</html>
